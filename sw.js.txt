// sw.js
const CACHE_VERSION = 'v1.0.0';          // ← 公開のたびに上げる（例: v1.0.1）
const CACHE_NAME = `anone-cache-${CACHE_VERSION}`;

const PRECACHE = [
  './',
  './index.html',
  './index.js',            // Godotの生成JS名に合わせて
  './godot.web.js',        // 4.x系の出力に合わせて必要分
  './godot.wasm',          // ↑ファイル名は出力物に合わせて
  './*.pck',               // pck名が固定ならそのファイル名
  './manifest.json',
  './coi-serviceworker.js'
];

// 拾いきれない動的アセット（icons/voice/pck等）はルールでCache-First
const RUNTIME_CACHE_RULES = [
  { pattern: /\/art\/icons\//, strategy: 'cache-first' },
  { pattern: /\/art\/voice\//, strategy: 'cache-first' },
  { pattern: /\.pck$/i, strategy: 'stale-while-revalidate' },
  { pattern: /\.wasm$/i, strategy: 'stale-while-revalidate' },
];

self.addEventListener('install', event => {
  event.waitUntil(
    caches.open(CACHE_NAME).then(cache => cache.addAll(PRECACHE))
      .then(() => self.skipWaiting())
  );
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(keys => Promise.all(
      keys.filter(k => k.startsWith('anone-cache-') && k !== CACHE_NAME)
          .map(k => caches.delete(k))
    )).then(() => self.clients.claim())
  );
});

self.addEventListener('fetch', event => {
  const url = new URL(event.request.url);
  // 同一オリジンのみ管理
  if (url.origin !== location.origin) return;

  // ルール適用
  for (const rule of RUNTIME_CACHE_RULES) {
    if (rule.pattern.test(url.pathname)) {
      if (rule.strategy === 'cache-first') {
        event.respondWith(cacheFirst(event.request));
        return;
      }
      if (rule.strategy === 'stale-while-revalidate') {
        event.respondWith(staleWhileRevalidate(event.request));
        return;
      }
    }
  }
  // 既定：ネット→ダメならキャッシュ
  event.respondWith(networkFallbackToCache(event.request));
});

async function cacheFirst(req) {
  const cache = await caches.open(CACHE_NAME);
  const hit = await cache.match(req);
  if (hit) return hit;
  const res = await fetch(req);
  cache.put(req, res.clone());
  return res;
}

async function staleWhileRevalidate(req) {
  const cache = await caches.open(CACHE_NAME);
  const cached = await cache.match(req);
  const network = fetch(req).then(res => { cache.put(req, res.clone()); return res; });
  return cached || network;
}

async function networkFallbackToCache(req) {
  try { return await fetch(req); }
  catch (_) {
    const cache = await caches.open(CACHE_NAME);
    const hit = await cache.match(req);
    if (hit) return hit;
    throw _;
  }
}
